---
title: "Call Stages"
description: Use Ultravox API to create dynamic, multi-stage conversations with granular system prompts.
---

import { Steps, Code } from '@astrojs/starlight/components';

The Ultravox API's Call Stages functionality allows you to create dynamic, multi-stage conversations by providing granular system prompts as your agent progresses through the interaction. Stages enable more complex and nuanced agent interactions, giving you fine-grained control over the conversation flow.

## Understanding Call Stages

Call Stages ("Stages") provide a way to segment a conversation into distinct phases, each with its own system prompt and potentially different parameters. This enables interactions that can adapt and change focus as the conversation progresses.

Key points to understand about Stages:

**Dynamic System Prompts** → Stages allow you to give granular system prompts to the model as the conversation progresses.

**Flexibility** → You have full control to determine when and how you want the conversation to progress to the next stage.

**Thoughtful Design** → Implementing stages requires careful planning and consideration of the conversation structure. Consider how to handle stage transitions and test thoroughly to ensure a natural flow to the conversation.

**Maintain Context** → Think about how the agent will maintain context about the user between stages if you need to ensure a coherent conversation.

:::note[Advanced Feature]
Stages require planning and careful implementation. Stages are likely not required for simple use cases.
:::

## Creating and Managing Stages

To implement Call Stages in your Ultravox application, follow these steps:

#### 1. Plan Your Stages
Determine the different phases of your conversation and what prompts or parameters should change at each stage.

#### 2. Implement a Stage Change Tool
Create a custom tool that will trigger stage changes when called. A new call stage is created when your tool responds with a header called `X-Ultravox-Response-Type` set to `new-stage` in the response.

Unless overridden, stages inherit all properties of the existing call. Here is the list of all call properties that can and cannot be changed during a new stage:

| property            | change with new stage? |
|-------------------- | ---------------------- |
| systemPrompt        | Yes                    |
| temperature         | Yes                    |
| voice               | Yes                    |
| languageHint        | Yes                    |
| initialMessages     | Yes                    |
| selectedTools       | Yes                    |
| firstSpeaker        | Yes                    |
| model               | No                     |
| joinTimeout         | No                     |
| maxDuration         | No                     |
| timeExceededMessage | No                     |
| inactivityMessages  | No                     |
| medium              | No                     |
| initiator           | No                     |
| recordingEnabled    | No                     |

The response body must contain the new values for any properties you want to change in the new stage.

#### 3. Set Up Stage Transitions
Prompt the agent to use tool calls to initiate stage changes at appropriate points in the conversation.

#### 4. Configure New Stage Parameters
When transitioning to a new stage, provide the updated parameters (e.g., system prompt) in the tool call.

### Example Stage Change Implementation

Here's a basic example of how to implement a new call stage.

First, we create a tool that is responsible for changing stages:

import callStageTool from '../../codesnippets/call-stage.txt?raw';
export const title = "Basic stage change tool"

<Code code={callStageTool} lang="js" title={title} />

We also need to ensure that we have instructed our agent to use the tool and that we add the tool to our `selectedTools` during the creation of the call.

import callStage from '../../codesnippets/call-stage-prompt.txt?raw';
export const cstitle = "Updating our systemPrompt and selectedTools"

<Code code={callStage} lang="js" title={cstitle} />


:::tip[Inheritance]
New stages inherit all properties from the previous stage. You can selectively overwrite properties as needed when defining a new stage. See the [above table](#2-implement-a-stage-change-tool) for more.
:::

## Use Cases for Call Stages

Call Stages are particularly useful for complex conversational flows. Here are some example scenarios:

**Data Gathering** → Scenarios where the agent needs to collect a lot of data. Examples: job applications, medical intake forms, applying for a mortgage.

Here are potential stages for a **Mortgage Application**:
- Stage 1: Greeting and basic information gathering
- Stage 2: Financial assessment
- Stage 3: Property evaluation
- Stage 4: Presentation of loan options
- Stage 5: Hand-off to loan officer

**Switching Contexts** → Scenarios where the agent needs to navigate different contexts. Examples: customer support escalation, triaging IT issues.
    
Let's consider what the potential stages might be for **Customer Support**: 
- Stage 1: Initial greeting and problem identification
- Stage 2: Troubleshooting
- Stage 3: Resolution or escalation (to another stage or to a human support agent)

## Conclusion

Call Stages in the Ultravox API give you the ability to create adaptive conversations for more complex scenarios like data gathering or switching contexts. By allowing granular control over system prompts and conversation parameters at different stages, you can create more dynamic and context-aware interactions.